""" main.py """
from pathlib import Path
from argparse import ArgumentParser, ArgumentError
from itertools import starmap
from matplotlib import pyplot as plt

from lucas_kanade.tracking_controller import TrackingController
from yolo.helpers.camera import Camera
from yolo.yolo_controller import YoloController
from fft.fourier_controller import FourierController


class Main:
    ANGLE_LIST = [0, 90, 180, 270]
    PARSED_FILES_PATH = str(Path.joinpath(Path.cwd(), '..', 'assets', 'parsed'))

    @classmethod
    def run(cls, video_path_list, parse=False, maneuver='DEFAULT', plot=False, plot_index=0):

        camera_list = list(
            starmap(
                lambda angle, path: Camera(
                    str(Path.joinpath(Path.cwd(), *(path.split('/')))),
                    angle
                ),
                zip(cls.ANGLE_LIST, video_path_list)
            )
        )

        min_video_length = min(list(map(lambda c: c.frame_count, camera_list)))

        yolo = YoloController(cameras=camera_list, debug=False)
        lucas_kanade = TrackingController(debug=True)

        i = 0
        while i < min_video_length:
            try:
                i = i + 1
                cars_list = yolo.get_cameras_images()
                lucas_kanade.receiver(cars_list)

            except KeyboardInterrupt:
                break

        abstract_vehicle_list = list()

        for car in lucas_kanade.car_list:
            abstract_vehicle_list.append(
                FourierController.build_abstract_vehicle(
                    car.ID,
                    list(map(lambda c: c.x, car.positions)),
                    list(map(lambda c: c.y, car.positions))
                )
            )

        if plot:
            plt.plot(list(map(lambda p: p.x, lucas_kanade.car_list[plot_index].positions)), label='X')
            plt.plot(list(map(lambda p: p.y, lucas_kanade.car_list[plot_index].positions)), label='Y')
            plt.legend(loc='best')
            plt.show()

        if parse:
            for car in abstract_vehicle_list:
                with open(f'{cls.PARSED_FILES_PATH}/{maneuver.upper()}/{maneuver.upper()}_{car.vehicle_id}') as f:
                    f.write(
                        f'{maneuver.upper()};{",".join(list(map(lambda s: s.x_sig, car.signal)))};{",".join(list(map(lambda s: s.y_sig, car.signal)))}'
                    )


if __name__ == '__main__':
    parser = ArgumentParser()

    optional_group = parser.add_argument_group('Optional Arguments')
    required_group = parser.add_argument_group('Required Arguments')

    optional_group.add_argument('--parse',
                                help='Boolean argument used to determine '
                                     'whether time series generated by the '
                                     'system should be stored for further training. '
                                     'Must inform --maneuver',
                                action='store_true')

    optional_group.add_argument('--maneuver',
                                help='Maneuver name so the parsed files may be saved properly',
                                nargs=1)

    optional_group.add_argument('--plot',
                                help='Boolean argument used for plotting a time series. Must inform --plot_index',
                                nargs=1,
                                action='store_true')

    optional_group.add_argument('--plot_index',
                                help='Index inside car list to plotted',
                                nargs=1)

    required_group.add_argument('--video_path_list',
                                help='Set of paths to access the videos for processing, '
                                     'i. e.: "path/to/file/one; path/to/file/2", '
                                     '4 files are required',
                                required=True)

    args = parser.parse_args()

    if any([all([args.parse, args.maneuver]), all([args.plot, args.plot_index])]):

        path_list = args.video_path_list.split(';')
        if len(path_list) != 4:
            raise ArgumentError('--video_path_list must contain 4 paths')

        Main.run(
            path_list,
            parse=args.parse,
            maneuver=args.maneuver,
            plot=args.plot,
            plot_index=args.plot_index
        )

    else:
        raise ArgumentError('arguments [--parse, --maneuver] and [--plot, --plot_index] '
                            'are required to be mutually inclusive')
